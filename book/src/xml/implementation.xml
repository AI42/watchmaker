<chapter xmlns="http://docbook.org/ns/docbook"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd">
  <title>Implementing Evolutionary Algorithms</title>
  <section>
    <title>Choice of Programming Language</title>
    <para>
      Evolutionary algorithms can be implemented in any general purpose programming language.
      Most programmers will simply choose the language that they are most comfortable with.
      A quick web search will return examples of evolutionary programs written in C, C++,
      Java, C#, Python, Ruby, Perl, Lisp and several other languages.
    </para>
    <para>
      Performance may be a consideration when choosing a language.
      Almost all evolutionary algorithms are CPU-bound.  For this reason, compiled languages
      typically offer better EA performance than interpreted languages.  For
      short-lived programs the difference is unlikely to be significant, but for
      long-running programs it could be considerable.
    </para>
    <para>
      If you can recall the title of this book, it should come as no surprise that we will be
      using Java for all of the example code.  Java offers a good balance of performance,
      ease-of-use and a rich standard library. 
    </para>
  </section>
  <section>
    <title>Frameworks</title>
    <section>
      <title>Why use a Framework?</title>
      <para>
        As we saw in chapter 1, the basic outline of an evolutionary algorithm is fairly
        straightforward.  It consists of a main loop that performs one generation per iteration,
        supplemented by a few functions to perform fitness evaluation, selection and
        mutation/cross-over.  When implementing a simple EA, writing this structural code is
        not particularly onerous.  However, if you write many different evolutionary
        programs, as we will be doing in the remainder of this book, you end up writing code
        that is very similar over and over again.
      </para>
      <para>
        A good programmer will usually want to extract and reuse this common code.
        Once you have done this, you have the basis of an evolutionary computation framework.
        Typically this will consist of an evolution engine that is reusable and that can
        accept different functions to customise fitness evaluation, selection and evolutionary
        operators.
      </para>
      <para>
        An alternative to using a home-grown framework is to choose a ready-made one.  There
        are open source evolutionary computation frameworks available for most programming languages.
        For popular languages, such as C, C++ and Java, there are dozens. 
      </para>
    </section>
    <section>
      <title>The Watchmaker Framework for Evolutionary Computation</title>
      <para>
        TO DO
      </para>
    </section>
  </section>
</chapter>
